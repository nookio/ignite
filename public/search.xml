<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Thrift源码分析--Transport]]></title>
    <url>%2F2017%2F08%2F16%2FThrift%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Transport%2F</url>
    <content type="text"><![CDATA[简介Thrift是一个RPC调用框架，因此底层会封装一层传输层，用来帮助构建好的代码进行数据的传输。其中TTransport封装了传输层，同时他也封装了上层的流。比如他的一个子类：TIOStreamTransport。里面使用的就是我们常用的socket的InputStream和outPutStream TTransport的设计理念是和我们生成的代码、协议层完全解耦。 我们生成的代码（Client）只需要处理读到的数据以及处理，并不需要关心如何去读取这个数据。 协议层也只需要进行数据的编解码。但是无需关心这些数据是如何来的，是使用的http还是socket还是file等。 TTransport结构：这个并不是一个完整的传输层，还有一部分是在服务端使用的，用来帮助生成的代码来创建一个默认的TTransport，供给服务端使用。如果不好理解，可以类比Socket和ServerSocket。 TServerTransport结构： 分析TTransport：下面是源码分析，已经对注解翻译，并且去掉了具体实现 12345678910111213141516171819202122232425262728public abstract class TTransport &#123; // 判断传输是否打开， public abstract boolean isOpen(); // 判断是否还有新的数据来 public boolean peek() &#123; return isOpen(); &#125; // 打开传输层，可以用来读写数据了 public abstract void open() throws TTransportException; // 关闭 public abstract void close(); // 读取指定长度的数据 public abstract int read(byte[] buf, int off, int len) throws TTransportException; // 把数据全部读取出来 public int readAll(byte[] buf, int off, int len) throws TTransportException; // 写数据，实际调用的是下面的方法 public void write(byte[] buf) throws TTransportException; // 写数据 public abstract void write(byte[] buf, int off, int len) throws TTransportException; // 把缓冲区的数据全部都push出去 public void flush() throws TTransportException;&#125; 在实现类中，有这么几个比较重要的子类： TIOStreamTransport: 这个类封装了InputStream和OutputStream这两个流，用来处理数据传输中的输入输出流。采用的是阻塞同步IO。 TSocket: 是上面这个类的子类，并且封装了Socket接口。 TNonblockingTransport: 这个类是非阻塞IO的抽象类。 TNonblockingSocket: 则是使用了SocketChannel进行了非阻塞IO。 TFileTransport: 这个类没有仔细研究，里面允许client把文件传输给服务端，同时允许服务端把文件写入到文件。 TFramedTransport: 帧传输类就是按照一帧的固定大小来传输数据，所有的写操作首先都是在内存中完成的直到调用了flush操作，然后传输节点在flush操作之后将所有数据根据数据的有效载荷写入数据的长度的二进制块发送出去，允许在接收的另一端按照固定的长度来读取。我司的封装是这里的cv操作。 TFastFramedTransport: 是快读类，相对于上面的类读取的效率会变的更高。 下面从源码角度分析几个比较重要的类: CASE：TIOStreamTransport，主要以翻译、删减无用代码尽可能突出主干 12345678910111213141516171819202122232425262728293031323334353637383940414243public class TIOStreamTransport extends TTransport &#123; // Underlying inputStream protected InputStream inputStream_ = null; // Underlying outputStream protected OutputStream outputStream_ = null; // 这里一共有四个构造方法，主要是对内部的两个传输流进行赋值 protected TIOStreamTransport() &#123;&#125; // 传入传输流在构造的时候就已经完成了打开，因此时时都是打开的 public boolean isOpen() &#123; return true; &#125; // 直接抛异常，两个流必须在构造的时候就已经打开了 public void open() throws TTransportException &#123;&#125; // 关闭流，调用两个流的close方法。去掉了其中的异常处理 public void close() &#123; inputStream_.close(); inputStream_ = null; outputStream_.close(); outputStream_ = null; &#125; // 读取数据，调用inputstream中的read方法 public int read(byte[] buf, int off, int len) throws TTransportException &#123; int bytesRead = inputStream_.read(buf, off, len); return bytesRead; &#125; // 写数据，调用outputstream中的read方法 public void write(byte[] buf, int off, int len) throws TTransportException &#123; outputStream_.write(buf, off, len); &#125; // 把缓冲区的数据push掉 public void flush() throws TTransportException &#123; outputStream_.flush(); &#125;&#125; 下面是他的唯一子类，TSocket，封装了Socket 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TSocket extends TIOStreamTransport &#123; // socket private Socket socket_ = null; // 远程的地址 private String host_ = null; // 远程端口 private int port_ = 0; // 超时时间 private int timeout_ = 0; // 构造方法，使用已经建立链接的socket进行操作 public TSocket(Socket socket) throws TTransportException &#123; socket_ = socket; if (isOpen()) &#123; inputStream_ = new BufferedInputStream(socket_.getInputStream(), 1024); outputStream_ = new BufferedOutputStream(socket_.getOutputStream(), 1024); &#125; &#125; // 构造方法 public TSocket(String host, int port, int timeout) &#123; // 省略直接赋值操作 initSocket(); &#125; // 创建新的链接 private void initSocket() &#123; socket_ = new Socket(); // 省略掉赋值操作 &#125; // 判断是否链接上了 public boolean isOpen() &#123; return socket_.isConnected(); &#125; // 打开链接 public void open() throws TTransportException &#123; socket_.connect(new InetSocketAddress(host_, port_), timeout_); inputStream_ = new BufferedInputStream(socket_.getInputStream(), 1024); outputStream_ = new BufferedOutputStream(socket_.getOutputStream(), 1024); &#125; // 关闭链接 public void close() &#123; // 关闭stream的关闭方法 super.close(); socket_.close(); socket_ = null; &#125;&#125; CASE:TNonblockingTransport抽象类 主要以翻译为主 123456789101112131415161718public abstract class TNonblockingTransport extends TTransport &#123; // 详情可以看下SocketChannel的connect方法，开启链接 public abstract boolean startConnect() throws IOException; // 详情可以看下SocketChannel的finishConnect方法，关闭链接 public abstract boolean finishConnect() throws IOException; // 注册到远程的selector public abstract SelectionKey registerSelector(Selector selector, int interests) throws IOException; // 读取数据，采用了ByteBuffer这个缓冲区 public abstract int read(ByteBuffer buffer) throws IOException; // 写入数据，采用了ByteBuffer这个缓冲区 public abstract int write(ByteBuffer buffer) throws IOException;&#125; 下面介绍的是他的唯一子类：TNonblockingSocket，需要看到懒加载的位置在哪里，暂时未知，为什么不需要flush呢1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class TNonblockingSocket extends TNonblockingTransport &#123; /** * Host and port if passed in, used for lazy non-blocking connect. */ private final SocketAddress socketAddress_; private final SocketChannel socketChannel_; //省略了若干了构造方法，核心构造方法 private TNonblockingSocket(SocketChannel socketChannel, int timeout, SocketAddress socketAddress) throws IOException &#123; socketChannel_ = socketChannel; socketAddress_ = socketAddress; // 设置非阻塞信道 socketChannel.configureBlocking(false); // 设置该信道里面的socket参数 Socket socket = socketChannel.socket(); socket.setSoLinger(false, 0); socket.setTcpNoDelay(true); setTimeout(timeout); &#125; // 注册一个新的选择器 public SelectionKey registerSelector(Selector selector, int interests) throws IOException &#123; return socketChannel_.register(selector, interests); &#125; // 设置超时时间 public void setTimeout(int timeout) &#123; socketChannel_.socket().setSoTimeout(timeout); &#125; // 判断当前信道是否开启 public boolean isOpen() &#123; // isConnect方法并不会在关闭以后返回false，所以这里使用isOpen方法 return socketChannel_.isOpen() &amp;&amp; socketChannel_.isConnected(); &#125; // 实现类实现了懒加载，所以不需要手动打开 public void open() throws TTransportException &#123; throw new RuntimeException("open() is not implemented for TNonblockingSocket"); &#125; // 使用ByteBuffer缓冲区读数据 public int read(ByteBuffer buffer) throws IOException &#123; return socketChannel_.read(buffer); &#125; // 使用ByteBuffer缓冲区写数据 public int write(ByteBuffer buffer) throws IOException &#123; return socketChannel_.write(buffer); &#125; // 不支持flush，为什么呢。没有缓冲区么 public void flush() throws TTransportException &#123; // Not supported by SocketChannel. &#125; // 关闭链接 public void close() &#123; socketChannel_.close(); &#125; /** &#123;@inheritDoc&#125; */ public boolean startConnect() throws IOException &#123; return socketChannel_.connect(socketAddress_); &#125; /** &#123;@inheritDoc&#125; */ public boolean finishConnect() throws IOException &#123; return socketChannel_.finishConnect(); &#125;&#125;]]></content>
      <tags>
        <tag>原理</tag>
        <tag>RPC</tag>
        <tag>源码</tag>
        <tag>Thrift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thrift源码分析--概述]]></title>
    <url>%2F2017%2F08%2F14%2FThrift%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[简介我司采用的RPC框架是apache开源的thrift，并在上层封装了服务注册和自动分配的功能，我将在两个部分分别介绍我司的RPC框架，首先是从底层进行分析整个的工作原理，下一步完成给thrift添加上下文，最终介绍我司的封装 Thrift源于Facebook, 目前已经作为开源项目提交给了Apahce。Thrift解决了Facebook各系统的大数据量传输通信和内部不同语言环境的跨平台调用。 官网Thrift的官方网站: http://thrift.apache.org/ 特点作为一个高性能的RPC框架，Thrift的主要特点有 基于二进制的高性能的编解码框架 基于NIO的底层通信 相对简单的服务调用模型 使用IDL支持跨平台调用 核心组件Thrift其中包含了如下的几个核心组件： TProtocol: 协议和编解码组件 TTransport: 传输组件 TProcessor: 服务调用组件 TServer，Client: 服务器和客户端组件 IDL: 服务描述组件，负责生产跨平台客户端 我会在后面的文章中依次介绍每一个组件 建议在学习本系列文章之前，建议具备的知识点： socket网络编程 NIO基础知识，以及nio socket实现机制]]></content>
      <tags>
        <tag>原理</tag>
        <tag>RPC</tag>
        <tag>源码</tag>
        <tag>Thrift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ClassLoader分析]]></title>
    <url>%2F2017%2F08%2F13%2FClassLoader%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ClassLoader的分类整体上一共有三种，也是classloader的加载顺序 bootstrap classLoader –这个是JVM级别的 extension classLoader –这个是扩展加载器 system classLoader –应用类加载器 下面依次介绍这三个ClassLoader. Bootstrap classLoader首先来说，这个加载器的被调用时机]]></content>
      <tags>
        <tag>Java</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生第一次写博客]]></title>
    <url>%2F2017%2F08%2F10%2Ffirst-page%2F</url>
    <content type="text"><![CDATA[1System.out.println("hello world"); READ MoreDo not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake 开始一步一步向工程师进攻～ 哈哈]]></content>
      <tags>
        <tag>测试</tag>
        <tag>哈哈</tag>
      </tags>
  </entry>
</search>
