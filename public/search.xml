<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Thrift源码分析--Protocol]]></title>
    <url>%2F2017%2F08%2F25%2FThrift%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Protocol%2F</url>
    <content type="text"><![CDATA[简介在介绍完IO流以后，基本上就知道了服务端和客户端是如何建立链接以及进行数据传输的，但是对于如何进行数据的序列化和反序列化，将在本文进行详 细记介绍。协议层的抽象类方法叫做：TProtocol,在包org.apache.thrift.protocol下。其中定义了协议的所有方法 TProtocol的UML图：分别定义了简版json协议、json传输协议、二进制传输协议、密集型（对int和long进行了长度压缩，采用了zigzag 编码）详情我会在后面继续介绍。 子类是我司封装的方法和官方的简版传输协议（对消息体进行了深度压缩） 先介绍下协议层需要完成的内容，定义了一个序列化和反序列化的协议: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * Transport */protected TTransport trans_;/** * Writing methods. */public abstract void writeMessageBegin(TMessage message) throws TException;public abstract void writeMessageEnd() throws TException;public abstract void writeStructBegin(TStruct struct) throws TException;public abstract void writeStructEnd() throws TException;public abstract void writeFieldBegin(TField field) throws TException;public abstract void writeFieldEnd() throws TException;public abstract void writeFieldStop() throws TException;public abstract void writeMapBegin(TMap map) throws TException;public abstract void writeMapEnd() throws TException;public abstract void writeListBegin(TList list) throws TException;public abstract void writeListEnd() throws TException;public abstract void writeSetBegin(TSet set) throws TException;public abstract void writeSetEnd() throws TException;public abstract void writeBool(boolean b) throws TException;public abstract void writeByte(byte b) throws TException;public abstract void writeI16(short i16) throws TException;public abstract void writeI32(int i32) throws TException;public abstract void writeI64(long i64) throws TException;public abstract void writeDouble(double dub) throws TException;public abstract void writeString(String str) throws TException;public abstract void writeBinary(ByteBuffer buf) throws TException;/** * Reading methods. */public abstract TMessage readMessageBegin() throws TException;public abstract void readMessageEnd() throws TException;public abstract TStruct readStructBegin() throws TException;public abstract void readStructEnd() throws TException;public abstract TField readFieldBegin() throws TException;public abstract void readFieldEnd() throws TException;public abstract TMap readMapBegin() throws TException;public abstract void readMapEnd() throws TException;public abstract TList readListBegin() throws TException;public abstract void readListEnd() throws TException;public abstract TSet readSetBegin() throws TException;public abstract void readSetEnd() throws TException;public abstract boolean readBool() throws TException;public abstract byte readByte() throws TException;public abstract short readI16() throws TException;public abstract int readI32() throws TException;public abstract long readI64() throws TException;public abstract double readDouble() throws TException;public abstract String readString() throws TException;public abstract ByteBuffer readBinary() throws TException;/** * Scheme accessor 用于选择标准传输协议还是简版协议 */public Class&lt;? extends IScheme&gt; getScheme() &#123; return StandardScheme.class;&#125; 需要注意的是在write方法里面，并没有wirte i32、bool、long、i16、double等并没有writeEnd方法，因为这些都是定长的 在这个协议里面定义了一个请求是如何被请求端打包，并且被服务端解包的。 在这个协议中有一个类叫做TMessage。可以简单来看一下源码：1234567891011121314151617181920212223242526272829303132333435public final class TMessage &#123; public TMessage() &#123; this("", TType.STOP, 0); &#125; public TMessage(String n, byte t, int s) &#123; name = n; type = t; seqid = s; &#125;//方法名字 public final String name;//类型，使用的是 org.apache.thrift.protocol.TMessageType中的枚举，目前使用的都是其中的CALL public final byte type;//目前都是0 public final int seqid; @Override public String toString() &#123; return "&lt;TMessage name:'" + name + "' type: " + type + " seqid:" + seqid + "&gt;"; &#125; @Override public boolean equals(Object other) &#123; if (other instanceof TMessage) &#123; return equals((TMessage) other); &#125; return false; &#125; public boolean equals(TMessage other) &#123; return name.equals(other.name) &amp;&amp; type == other.type &amp;&amp; seqid == other.seqid; &#125;&#125; 下面来详细解释下协议层的使用。首先来看其中定义的方法。TTransport:这个是传输层，Thrift传输层—I/O操作剩下的就是一个如何来构造一次传输的内容。先看分类，整体上分为两个大类别，每一个方法都有写和读的方法在对应着。先来说说写方法。 A首先是定义了一个方法调用的开始writeMessageBegin，这个方法中写入TMessage这个对象，其中包含了调用的方法名字，调用类型（目前看到的都是CALL），以及当前消息的序列（可能与传输层有关）。 B根据函数中定义的参数顺序，依次调用相应的写方法和写结束方法（只有不可知长度的类型才需要结束方法）。写入字段的消息类型和消息长度，以及消息顺序号。 比如如何写入string这个类型 1234567891011public void writeString(String str) throws TException &#123; try &#123; byte[] dat = str.getBytes("UTF-8"); //写入数组长度是i32，也就是说超长会出问题－ － writeI32(dat.length); //在传输层里面写入相应长度的数据 trans_.write(dat, 0, dat.length); &#125; catch (UnsupportedEncodingException uex) &#123; throw new TException("JVM DOES NOT SUPPORT UTF-8"); &#125;&#125; 再比如如何写入map这个类型在写入之前用到的一些类型：1234567891011121314151617//首先是定义了TMap这个对象public final class TMap &#123; public TMap() &#123; this(TType.STOP, TType.STOP, 0); &#125; public TMap(byte k, byte v, int s) &#123; keyType = k; valueType = v; size = s; &#125;//key类型 public final byte keyType;//value类型 public final byte valueType; public final int size;&#125; 其中引用了一个新的对象教TType。1234567891011121314151617//其中对key和value的定义是在 org.apache.thrift.protocol.TTypepublic final class TType &#123; public static final byte STOP = 0; public static final byte VOID = 1; public static final byte BOOL = 2; public static final byte BYTE = 3; public static final byte DOUBLE = 4; public static final byte I16 = 6; public static final byte I32 = 8; public static final byte I64 = 10; public static final byte STRING = 11; public static final byte STRUCT = 12; public static final byte MAP = 13; public static final byte SET = 14; public static final byte LIST = 15; public static final byte ENUM = 16;&#125; 下面是正式的写入map这个对象,一共有两种写入方法，分别为标准写入和Tuple写入（简版）？ 下面对比两种的写入的不同点: 标准写入12345678910111213141516if (struct.testMap != null) &#123; if (struct.isSetTestMap()) &#123; //这个参数是指TField其中表名了参数类型，名字，和id oprot.writeFieldBegin(TEST_MAP_FIELD_DESC); &#123; oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.I32, struct.testMap.size())); for (Map.Entry&lt;String, Integer&gt; _iter4 : struct.testMap.entrySet()) &#123; oprot.writeString(_iter4.getKey()); oprot.writeI32(_iter4.getValue()); &#125; oprot.writeMapEnd(); &#125; oprot.writeFieldEnd(); &#125;&#125; 下面是其中的一段field的代码1234567891011121314151617181920212223242526public class TField &#123; public TField() &#123; this("", TType.STOP, (short)0); &#125; public TField(String n, byte t, short i) &#123; name = n; type = t; id = i; &#125;//字段名字 public final String name;//字段类型详情在下面 public final byte type;//id，会增长 public final short id; public String toString() &#123; return "&lt;TField name:'" + name + "' type:" + type + " field-id:" + id + "&gt;"; &#125; public boolean equals(TField otherField) &#123; return type == otherField.type &amp;&amp; id == otherField.id; &#125;&#125; 简单版本12345678910if (struct.isSetTestMap()) &#123; &#123; oprot.writeI32(struct.testMap.size()); for (Map.Entry&lt;String, Integer&gt; _iter5 : struct.testMap.entrySet()) &#123; oprot.writeString(_iter5.getKey()); oprot.writeI32(_iter5.getValue()); &#125; &#125;&#125; 可见简版的写入相对于标准更节省空间。因此传输效率更高。我司采用的是标准传输协议。在读取的时候采用的是对应的方法标准协议：123456789101112131415161718192021case 4: // TEST_MAP if (schemeField.type == org.apache.thrift.protocol.TType.MAP) &#123; &#123; org.apache.thrift.protocol.TMap _map0 = iprot.readMapBegin(); struct.testMap = new HashMap&lt;String,Integer&gt;(2*_map0.size); for (int _i1 = 0; _i1 &lt; _map0.size; ++_i1) &#123; String _key2; // required int _val3; // required _key2 = iprot.readString(); _val3 = iprot.readI32(); struct.testMap.put(_key2, _val3); &#125; iprot.readMapEnd(); &#125; struct.setTestMapIsSet(true); &#125; else &#123; org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type); &#125; break; 简单版本123456789101112131415if (incoming.get(1)) &#123; //incoming标示了有哪些optional被赋值 &#123; org.apache.thrift.protocol.TMap _map6 = new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.I32, iprot.readI32()); struct.testMap = new HashMap&lt;String,Integer&gt;(2*_map6.size); for (int _i7 = 0; _i7 &lt; _map6.size; ++_i7) &#123; String _key8; // required int _val9; // required _key8 = iprot.readString(); _val9 = iprot.readI32(); struct.testMap.put(_key8, _val9); &#125; &#125; struct.setTestMapIsSet(true);&#125; C然后writeMessageEnd，完成了消息的写入 整体上来说，如果想要对代码进行缩减或者是更改，需要注意的地方很多，比如读写的顺序。而且在不断的发版过程中的变量顺序调整也会影响数据的序列化和反序列化。因此借用官方的一句话：123456/** * Autogenerated by Thrift Compiler (0.8.0) * * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING * @generated */]]></content>
      <tags>
        <tag>原理</tag>
        <tag>RPC</tag>
        <tag>源码</tag>
        <tag>Thrift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thrift源码分析--Transport]]></title>
    <url>%2F2017%2F08%2F16%2FThrift%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Transport%2F</url>
    <content type="text"><![CDATA[简介Thrift是一个RPC调用框架，因此底层会封装一层传输层，用来帮助构建好的代码进行数据的传输。其中TTransport封装了传输层，同时他也封装了上层的流。比如他的一个子类：TIOStreamTransport。里面使用的就是我们常用的socket的InputStream和outPutStream TTransport的设计理念是和我们生成的代码、协议层完全解耦。 我们生成的代码（Client）只需要处理读到的数据以及处理，并不需要关心如何去读取这个数据。 协议层也只需要进行数据的编解码。但是无需关心这些数据是如何来的，是使用的http还是socket还是file等。 TTransport结构这个并不是一个完整的传输层，还有一部分是在服务端使用的，用来帮助生成的代码来创建一个默认的TTransport，供给服务端使用。如果不好理解，可以类比Socket和ServerSocket。 TServerTransport结构 分析TTransport下面是源码分析，已经对注解翻译，并且去掉了具体实现 12345678910111213141516171819202122232425262728public abstract class TTransport &#123; // 判断传输是否打开， public abstract boolean isOpen(); // 判断是否还有新的数据来 public boolean peek() &#123; return isOpen(); &#125; // 打开传输层，可以用来读写数据了 public abstract void open() throws TTransportException; // 关闭 public abstract void close(); // 读取指定长度的数据 public abstract int read(byte[] buf, int off, int len) throws TTransportException; // 把数据全部读取出来 public int readAll(byte[] buf, int off, int len) throws TTransportException; // 写数据，实际调用的是下面的方法 public void write(byte[] buf) throws TTransportException; // 写数据 public abstract void write(byte[] buf, int off, int len) throws TTransportException; // 把缓冲区的数据全部都push出去 public void flush() throws TTransportException;&#125; 在实现类中，有这么几个比较重要的子类： TIOStreamTransport: 这个类封装了InputStream和OutputStream这两个流，用来处理数据传输中的输入输出流。采用的是阻塞同步IO。 TSocket: 是上面这个类的子类，并且封装了Socket接口。 TNonblockingTransport: 这个类是非阻塞IO的抽象类。 TNonblockingSocket: 则是使用了SocketChannel进行了非阻塞IO。 TFileTransport: 这个类没有仔细研究，里面允许client把文件传输给服务端，同时允许服务端把文件写入到文件。 TFramedTransport: 帧传输类就是按照一帧的固定大小来传输数据，所有的写操作首先都是在内存中完成的直到调用了flush操作，然后传输节点在flush操作之后将所有数据根据数据的有效载荷写入数据的长度的二进制块发送出去，允许在接收的另一端按照固定的长度来读取。我司的封装是这里的cv操作。 TFastFramedTransport: 是快读类，相对于上面的类读取的效率会变的更高。 下面从源码角度分析几个比较重要的类: CASE：TIOStreamTransport，主要以翻译、删减无用代码尽可能突出主干 12345678910111213141516171819202122232425262728293031323334353637383940414243public class TIOStreamTransport extends TTransport &#123; // Underlying inputStream protected InputStream inputStream_ = null; // Underlying outputStream protected OutputStream outputStream_ = null; // 这里一共有四个构造方法，主要是对内部的两个传输流进行赋值 protected TIOStreamTransport() &#123;&#125; // 传入传输流在构造的时候就已经完成了打开，因此时时都是打开的 public boolean isOpen() &#123; return true; &#125; // 直接抛异常，两个流必须在构造的时候就已经打开了 public void open() throws TTransportException &#123;&#125; // 关闭流，调用两个流的close方法。去掉了其中的异常处理 public void close() &#123; inputStream_.close(); inputStream_ = null; outputStream_.close(); outputStream_ = null; &#125; // 读取数据，调用inputstream中的read方法 public int read(byte[] buf, int off, int len) throws TTransportException &#123; int bytesRead = inputStream_.read(buf, off, len); return bytesRead; &#125; // 写数据，调用outputstream中的read方法 public void write(byte[] buf, int off, int len) throws TTransportException &#123; outputStream_.write(buf, off, len); &#125; // 把缓冲区的数据push掉 public void flush() throws TTransportException &#123; outputStream_.flush(); &#125;&#125; 下面是他的唯一子类，TSocket，封装了Socket 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TSocket extends TIOStreamTransport &#123; // socket private Socket socket_ = null; // 远程的地址 private String host_ = null; // 远程端口 private int port_ = 0; // 超时时间 private int timeout_ = 0; // 构造方法，使用已经建立链接的socket进行操作 public TSocket(Socket socket) throws TTransportException &#123; socket_ = socket; if (isOpen()) &#123; inputStream_ = new BufferedInputStream(socket_.getInputStream(), 1024); outputStream_ = new BufferedOutputStream(socket_.getOutputStream(), 1024); &#125; &#125; // 构造方法 public TSocket(String host, int port, int timeout) &#123; // 省略直接赋值操作 initSocket(); &#125; // 创建新的链接 private void initSocket() &#123; socket_ = new Socket(); // 省略掉赋值操作 &#125; // 判断是否链接上了 public boolean isOpen() &#123; return socket_.isConnected(); &#125; // 打开链接 public void open() throws TTransportException &#123; socket_.connect(new InetSocketAddress(host_, port_), timeout_); inputStream_ = new BufferedInputStream(socket_.getInputStream(), 1024); outputStream_ = new BufferedOutputStream(socket_.getOutputStream(), 1024); &#125; // 关闭链接 public void close() &#123; // 关闭stream的关闭方法 super.close(); socket_.close(); socket_ = null; &#125;&#125; CASE:TNonblockingTransport抽象类 主要以翻译为主 123456789101112131415161718public abstract class TNonblockingTransport extends TTransport &#123; // 详情可以看下SocketChannel的connect方法，开启链接 public abstract boolean startConnect() throws IOException; // 详情可以看下SocketChannel的finishConnect方法，关闭链接 public abstract boolean finishConnect() throws IOException; // 注册到远程的selector public abstract SelectionKey registerSelector(Selector selector, int interests) throws IOException; // 读取数据，采用了ByteBuffer这个缓冲区 public abstract int read(ByteBuffer buffer) throws IOException; // 写入数据，采用了ByteBuffer这个缓冲区 public abstract int write(ByteBuffer buffer) throws IOException;&#125; 下面介绍的是他的唯一子类：TNonblockingSocket，需要看到懒加载的位置在哪里，暂时未知，为什么不需要flush呢1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class TNonblockingSocket extends TNonblockingTransport &#123; /** * Host and port if passed in, used for lazy non-blocking connect. */ private final SocketAddress socketAddress_; private final SocketChannel socketChannel_; //省略了若干了构造方法，核心构造方法 private TNonblockingSocket(SocketChannel socketChannel, int timeout, SocketAddress socketAddress) throws IOException &#123; socketChannel_ = socketChannel; socketAddress_ = socketAddress; // 设置非阻塞信道 socketChannel.configureBlocking(false); // 设置该信道里面的socket参数 Socket socket = socketChannel.socket(); socket.setSoLinger(false, 0); socket.setTcpNoDelay(true); setTimeout(timeout); &#125; // 注册一个新的选择器 public SelectionKey registerSelector(Selector selector, int interests) throws IOException &#123; return socketChannel_.register(selector, interests); &#125; // 设置超时时间 public void setTimeout(int timeout) &#123; socketChannel_.socket().setSoTimeout(timeout); &#125; // 判断当前信道是否开启 public boolean isOpen() &#123; // isConnect方法并不会在关闭以后返回false，所以这里使用isOpen方法 return socketChannel_.isOpen() &amp;&amp; socketChannel_.isConnected(); &#125; // 实现类实现了懒加载，所以不需要手动打开 public void open() throws TTransportException &#123; throw new RuntimeException("open() is not implemented for TNonblockingSocket"); &#125; // 使用ByteBuffer缓冲区读数据 public int read(ByteBuffer buffer) throws IOException &#123; return socketChannel_.read(buffer); &#125; // 使用ByteBuffer缓冲区写数据 public int write(ByteBuffer buffer) throws IOException &#123; return socketChannel_.write(buffer); &#125; // 不支持flush，为什么呢。没有缓冲区么 public void flush() throws TTransportException &#123; // Not supported by SocketChannel. &#125; // 关闭链接 public void close() &#123; socketChannel_.close(); &#125; /** &#123;@inheritDoc&#125; */ public boolean startConnect() throws IOException &#123; return socketChannel_.connect(socketAddress_); &#125; /** &#123;@inheritDoc&#125; */ public boolean finishConnect() throws IOException &#123; return socketChannel_.finishConnect(); &#125;&#125;]]></content>
      <tags>
        <tag>原理</tag>
        <tag>RPC</tag>
        <tag>源码</tag>
        <tag>Thrift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thrift源码分析--原生调用例子]]></title>
    <url>%2F2017%2F08%2F15%2FThrift%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8E%9F%E7%94%9F%E8%B0%83%E7%94%A8%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[简介在所有的内容开始之前，我们来使用一下，最原始的Thrift用法。并且附上源码～ Thrift文件(idl)1234567namespace java com.kris.thrift.demo.serviceservice DemoService &#123; //hello world string helloWorld(1:string name)&#125; Server端(java)12345678910111213141516171819202122232425262728293031323334353637package com.kris.thrift.demo.service;import org.apache.thrift.TProcessor;import org.apache.thrift.protocol.TBinaryProtocol;import org.apache.thrift.server.TServer;import org.apache.thrift.server.TSimpleServer;import org.apache.thrift.transport.TServerSocket;public class Server&#123; public static final int SERVER_PORT = 9001; public void startServer() &#123; try &#123; System.out.println("TSimpleServer start ...."); TProcessor tprocessor = new DemoService.Processor&lt;DemoService.Iface&gt;( new DemoServiceImpl()); TServerSocket serverTransport = new TServerSocket(SERVER_PORT); TServer.Args tArgs = new TServer.Args(serverTransport); tArgs.processor(tprocessor); tArgs.protocolFactory(new TBinaryProtocol.Factory()); TServer server = new TSimpleServer(tArgs); server.serve(); &#125; catch (Exception e) &#123; System.out.println("Server start error!!!"); e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Server server = new Server(); server.startServer(); &#125;&#125; Client(java)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.kris.thrift.demo.service;import org.apache.thrift.TException;import org.apache.thrift.protocol.TBinaryProtocol;import org.apache.thrift.protocol.TProtocol;import org.apache.thrift.transport.TSocket;import org.apache.thrift.transport.TTransport;import org.apache.thrift.transport.TTransportException;import org.apache.thrift.transport.TFramedTransport;import java.net.Inet4Address;import java.net.InetAddress;import java.net.NetworkInterface;import java.net.SocketException;import java.util.Enumeration;public class Client &#123; public static final int SERVER_PORT = 9001; public static final int TIMEOUT = 30000; public static TTransport transport = null; public static DemoService.Client client; public static void initClient() &#123; try &#123; transport = new TSocket(getLocalIp(), SERVER_PORT, TIMEOUT); transport.open(); TProtocol protocol = new TBinaryProtocol(transport); client = new DemoService.Client(protocol); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void destroyClient()&#123; if (null != transport) transport.close(); &#125; public static String getLocalIp()&#123; String ipAddress = null; Enumeration&lt;NetworkInterface&gt; net = null; try &#123; net = NetworkInterface.getNetworkInterfaces(); &#125; catch (SocketException e) &#123; throw new RuntimeException(e); &#125; while(net.hasMoreElements())&#123; NetworkInterface element = net.nextElement(); Enumeration&lt;InetAddress&gt; addresses = element.getInetAddresses(); while (addresses.hasMoreElements())&#123; InetAddress ip = addresses.nextElement(); if (ip instanceof Inet4Address)&#123; if (ip.isSiteLocalAddress())&#123; ipAddress = ip.getHostAddress(); &#125; &#125; &#125; &#125; return ipAddress; &#125;&#125; 代码下载地址Demo]]></content>
      <tags>
        <tag>原理</tag>
        <tag>RPC</tag>
        <tag>源码</tag>
        <tag>Thrift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thrift源码分析--概述]]></title>
    <url>%2F2017%2F08%2F14%2FThrift%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[简介我司采用的RPC框架是apache开源的thrift，并在上层封装了服务注册和自动分配的功能，我将在两个部分分别介绍我司的RPC框架，首先是从底层进行分析整个的工作原理，下一步完成给thrift添加上下文，最终介绍我司的封装 Thrift源于Facebook, 目前已经作为开源项目提交给了Apahce。Thrift解决了Facebook各系统的大数据量传输通信和内部不同语言环境的跨平台调用。 官网Thrift的官方网站: http://thrift.apache.org/ 特点作为一个高性能的RPC框架，Thrift的主要特点有 基于二进制的高性能的编解码框架 基于NIO的底层通信 相对简单的服务调用模型 使用IDL支持跨平台调用 核心组件Thrift其中包含了如下的几个核心组件： TProtocol: 协议和编解码组件 TTransport: 传输组件 TProcessor: 服务调用组件 TServer，Client: 服务器和客户端组件 IDL: 服务描述组件，负责生产跨平台客户端 我会在后面的文章中依次介绍每一个组件 建议在学习本系列文章之前，建议具备的知识点： socket网络编程 NIO基础知识，以及nio、socket实现机制]]></content>
      <tags>
        <tag>原理</tag>
        <tag>RPC</tag>
        <tag>源码</tag>
        <tag>Thrift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ClassLoader分析]]></title>
    <url>%2F2017%2F08%2F13%2FClassLoader%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ClassLoader的分类整体上一共有三种，也是classloader的加载顺序 bootstrap classLoader –这个是JVM级别的 extension classLoader –这个是扩展加载器 system classLoader –应用类加载器 下面依次介绍这三个ClassLoader. Bootstrap classLoader首先来说，这个加载器的被调用时机]]></content>
      <tags>
        <tag>Java</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生第一次写博客]]></title>
    <url>%2F2017%2F08%2F10%2Ffirst-page%2F</url>
    <content type="text"><![CDATA[1System.out.println("hello world"); READ MoreDo not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake 开始一步一步向工程师进攻～ 哈哈]]></content>
      <tags>
        <tag>测试</tag>
        <tag>哈哈</tag>
      </tags>
  </entry>
</search>
